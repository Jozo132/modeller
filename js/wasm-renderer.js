// wasm-renderer.js — WASM-backed renderer for 2D sketching and 3D viewing
// Loads the AssemblyScript WASM module, manages scene state via WASM exports,
// and uses WebGLExecutor to process batched WebGL commands.

import { WebGLExecutor } from './webgl-executor.js';

/**
 * WasmRenderer — WASM-backed renderer for 2D and 3D views.
 *
 * Public surface used by main.js:
 *   - constructor(container)
 *   - setMode(mode)           '2d' | '3d'
 *   - setVisible(visible)
 *   - onWindowResize()
 *   - sync2DView(viewport)
 *   - render2DScene(scene, overlays)
 *   - renderPart(part)
 *   - clearPartGeometry()
 *   - clearGeometry()
 *   - fitToView()
 *   - screenToWorld(sx, sy)
 *   - dispose()
 *   - renderer.domElement        (the <canvas>)
 */
export class WasmRenderer {
  constructor(container) {
    this.container = container;
    this.mode = '2d';
    this._ready = false;

    // Create a <canvas> that fills the container
    this.canvas = document.createElement('canvas');
    this.canvas.style.width = '100%';
    this.canvas.style.height = '100%';
    this.canvas.style.display = 'block';
    container.appendChild(this.canvas);

    const width = container.clientWidth || 800;
    const height = container.clientHeight || 600;
    this.canvas.width = width;
    this.canvas.height = height;

    // WebGL executor
    this.executor = new WebGLExecutor(this.canvas);

    // 2D overlay canvas for text/sprites/dimension labels
    this.overlayCanvas = document.createElement('canvas');
    this.overlayCanvas.style.position = 'absolute';
    this.overlayCanvas.style.left = '0';
    this.overlayCanvas.style.top = '0';
    this.overlayCanvas.style.width = '100%';
    this.overlayCanvas.style.height = '100%';
    this.overlayCanvas.style.pointerEvents = 'none';
    this.overlayCanvas.width = width;
    this.overlayCanvas.height = height;
    container.appendChild(this.overlayCanvas);
    this.overlayCtx = this.overlayCanvas.getContext('2d');

    // Compatibility shim: renderer.domElement
    this.renderer = { domElement: this.canvas };

    // WASM module handle (set after load)
    this.wasm = null;
    this.wasmMemory = null;

    // View state for 2D
    this._orthoBounds = { left: -500, right: 500, bottom: -375, top: 375 };
    this._cameraPos = { x: 0, y: 0, z: 500 };

    // 3D orbit camera state (spherical coordinates around target)
    this._orbitTheta = Math.PI / 4;   // azimuthal angle (around Z axis)
    this._orbitPhi = Math.PI / 3;     // polar angle (from Z axis)
    this._orbitRadius = 500;
    this._orbitTarget = { x: 0, y: 0, z: 0 };
    this._orbitDirty = true;

    // 3D interaction state
    this._isDragging = false;
    this._isPanning3D = false;
    this._lastMouseX = 0;
    this._lastMouseY = 0;

    // Bind 3D mouse controls
    this._bind3DControls();

    // Part data stored for 3D render
    this._partNodes = [];
    this._partBounds = null;

    // Pre-built mesh data for direct WebGL rendering (bypasses WASM scene nodes)
    this._meshTriangles = null;  // Float32Array: interleaved [x,y,z,nx,ny,nz, ...]
    this._meshTriangleCount = 0;
    this._meshEdges = null;      // Float32Array: [x,y,z, x,y,z, ...] line pairs
    this._meshEdgeVertexCount = 0;

    // Sketch wireframe data for rendering sketch primitives in 3D
    this._sketchEdges = null;     // Float32Array: [x,y,z, x,y,z, ...] line pairs
    this._sketchEdgeVertexCount = 0;

    // Selected face in 3D mode
    this._selectedFaceIndex = -1;

    // Sketch plane reference (set when in sketch-on-plane mode)
    this._sketchPlane = null; // 'XY', 'XZ', 'YZ', or null

    // Window resize handler
    this._resizeHandler = () => this.onWindowResize();
    window.addEventListener('resize', this._resizeHandler);

    // Load WASM
    this._loadPromise = this._loadWasm();

    // Start animation loop
    this._animationId = null;
    this._animate();
  }

  async _loadWasm() {
    try {
      // Use the ESM bindings generated by AssemblyScript
      const mod = await import('../build/release.js');
      this.wasm = mod;
      const width = this.canvas.width;
      const height = this.canvas.height;
      this.wasm.init(width, height);
      this._ready = true;
      // Apply deferred mode setup now that WASM is loaded
      this.setMode(this.mode);
    } catch (err) {
      console.error('WasmRenderer: failed to load WASM module', err);
    }
  }

  /* ---------- animation loop ---------- */
  _animate() {
    this._animationId = requestAnimationFrame(() => this._animate());
    if (!this._ready) return;
    this._renderFrame();
  }

  _renderFrame() {
    const wasm = this.wasm;
    if (!wasm) return;

    // Update 3D camera from orbit state if dirty
    if (this.mode === '3d' && this._orbitDirty) {
      this._applyOrbitCamera();
      this._orbitDirty = false;
    }

    wasm.render();
    const ptr = wasm.getCommandBufferPtr();
    const len = wasm.getCommandBufferLen();
    if (len <= 0) return;

    // Read command buffer from WASM linear memory
    const memory = wasm.memory || (wasm.__getMemory && wasm.__getMemory());
    if (!memory) return;
    const buf = new Float32Array(memory.buffer, ptr, len);
    this.executor.execute(buf, len);

    // Render Part mesh directly via WebGL (after WASM pass)
    if (this.mode === '3d') {
      this._renderMeshOverlay();
    }
  }

  /* ---------- 3D orbit controls ---------- */

  _bind3DControls() {
    const canvas = this.canvas;

    canvas.addEventListener('mousedown', (e) => {
      if (this.mode !== '3d') return;
      // Left button = orbit, Middle button = pan, Shift+Left = pan
      if (e.button === 0 && e.shiftKey) {
        this._isPanning3D = true;
        this._isDragging = false;
      } else if (e.button === 0) {
        this._isDragging = true;
        this._isPanning3D = false;
      } else if (e.button === 1) {
        e.preventDefault();
        this._isPanning3D = true;
        this._isDragging = false;
      }
      this._lastMouseX = e.clientX;
      this._lastMouseY = e.clientY;
    });

    canvas.addEventListener('mousemove', (e) => {
      if (this.mode !== '3d') return;
      const dx = e.clientX - this._lastMouseX;
      const dy = e.clientY - this._lastMouseY;
      this._lastMouseX = e.clientX;
      this._lastMouseY = e.clientY;

      if (this._isDragging) {
        // Orbit: adjust theta (azimuth) and phi (elevation)
        this._orbitTheta -= dx * 0.005;
        this._orbitPhi -= dy * 0.005;
        // Clamp phi to avoid flipping
        this._orbitPhi = Math.max(0.05, Math.min(Math.PI - 0.05, this._orbitPhi));
        this._orbitDirty = true;
      } else if (this._isPanning3D) {
        // Pan: move target in the camera's local right/up plane
        const panSpeed = this._orbitRadius * 0.002;
        const theta = this._orbitTheta;
        const phi = this._orbitPhi;

        // Camera right vector (perpendicular to view direction in XY plane)
        const rightX = -Math.sin(theta);
        const rightY = Math.cos(theta);
        // Camera up vector (world Z projected)
        const upX = -Math.cos(theta) * Math.cos(phi);
        const upY = -Math.sin(theta) * Math.cos(phi);
        const upZ = Math.sin(phi);

        this._orbitTarget.x += (-dx * rightX + dy * upX) * panSpeed;
        this._orbitTarget.y += (-dx * rightY + dy * upY) * panSpeed;
        this._orbitTarget.z += dy * upZ * panSpeed;
        this._orbitDirty = true;
      }
    });

    canvas.addEventListener('mouseup', () => {
      this._isDragging = false;
      this._isPanning3D = false;
    });

    canvas.addEventListener('mouseleave', () => {
      this._isDragging = false;
      this._isPanning3D = false;
    });

    canvas.addEventListener('wheel', (e) => {
      if (this.mode !== '3d') return;
      e.preventDefault();
      const factor = e.deltaY > 0 ? 1.1 : 0.9;
      this._orbitRadius *= factor;
      this._orbitRadius = Math.max(10, Math.min(5000, this._orbitRadius));
      this._orbitDirty = true;
    }, { passive: false });
  }

  _applyOrbitCamera() {
    if (!this._ready) return;
    const theta = this._orbitTheta;
    const phi = this._orbitPhi;
    const r = this._orbitRadius;
    const t = this._orbitTarget;

    const camX = t.x + r * Math.sin(phi) * Math.cos(theta);
    const camY = t.y + r * Math.sin(phi) * Math.sin(theta);
    const camZ = t.z + r * Math.cos(phi);

    this.wasm.setCameraPosition(camX, camY, camZ);
    this.wasm.setCameraTarget(t.x, t.y, t.z);
  }

  /**
   * Orient the orbit camera perpendicular to the given plane.
   * @param {'XY'|'XZ'|'YZ'} plane - The reference plane
   */
  orientToPlane(plane) {
    switch (plane) {
      case 'XY':
        // Look down the Z axis (top view): phi=0 means camera on +Z
        this._orbitTheta = Math.PI / 2;
        this._orbitPhi = 0.001; // near 0 to look straight down +Z
        break;
      case 'XZ':
        // Look down the Y axis (front view): camera on +Y looking at origin
        this._orbitTheta = Math.PI / 2;
        this._orbitPhi = Math.PI / 2;
        break;
      case 'YZ':
        // Look down the X axis (right view): camera on +X looking at origin
        this._orbitTheta = 0;
        this._orbitPhi = Math.PI / 2;
        break;
      default:
        return;
    }
    this._orbitDirty = true;
    this._applyOrbitCamera();
  }

  /**
   * Orient the orbit camera perpendicular to a plane defined by a normal vector.
   * @param {{x:number, y:number, z:number}} normal - The plane normal
   * @param {{x:number, y:number, z:number}} [center] - Optional center point to look at
   */
  orientToPlaneNormal(normal, center) {
    // Convert normal direction to spherical coordinates (theta, phi)
    const nx = normal.x, ny = normal.y, nz = normal.z;
    const len = Math.sqrt(nx * nx + ny * ny + nz * nz);
    if (len < 1e-10) return;
    const dnx = nx / len, dny = ny / len, dnz = nz / len;

    // phi is angle from Z axis: acos(nz)
    this._orbitPhi = Math.acos(Math.max(-1, Math.min(1, dnz)));
    // theta is angle in XY plane: atan2(ny, nx)
    this._orbitTheta = Math.atan2(dny, dnx);

    // Clamp phi to avoid degeneracies
    if (this._orbitPhi < 0.001) this._orbitPhi = 0.001;
    if (this._orbitPhi > Math.PI - 0.001) this._orbitPhi = Math.PI - 0.001;

    if (center) {
      this._orbitTarget = { x: center.x, y: center.y, z: center.z };
    }

    this._orbitDirty = true;
    this._applyOrbitCamera();
  }

  /**
   * Pick a face at the given screen coordinates using ray-triangle intersection.
   * @param {number} screenX - Screen X coordinate
   * @param {number} screenY - Screen Y coordinate
   * @returns {{faceIndex: number, face: Object, point: {x:number,y:number,z:number}}|null}
   */
  pickFace(screenX, screenY) {
    if (!this._meshTriangles || this._meshTriangleCount === 0 || !this._meshFaces) return null;

    const rect = this.canvas.getBoundingClientRect();
    const ndcX = ((screenX - rect.left) / rect.width) * 2 - 1;
    const ndcY = -((screenY - rect.top) / rect.height) * 2 + 1;

    // Compute camera ray in world space
    const mvp = this._computeMVP();
    if (!mvp) return null;

    // Invert MVP to get ray
    const invMVP = this._mat4Invert(mvp);
    if (!invMVP) return null;

    // Near point (NDC z = -1) and far point (NDC z = 1)
    const nearW = this._mat4TransformVec4(invMVP, ndcX, ndcY, -1, 1);
    const farW = this._mat4TransformVec4(invMVP, ndcX, ndcY, 1, 1);
    if (Math.abs(nearW.w) < 1e-10 || Math.abs(farW.w) < 1e-10) return null;

    const origin = { x: nearW.x / nearW.w, y: nearW.y / nearW.w, z: nearW.z / nearW.w };
    const farPt = { x: farW.x / farW.w, y: farW.y / farW.w, z: farW.z / farW.w };
    const dir = {
      x: farPt.x - origin.x,
      y: farPt.y - origin.y,
      z: farPt.z - origin.z,
    };
    const dirLen = Math.sqrt(dir.x * dir.x + dir.y * dir.y + dir.z * dir.z);
    if (dirLen < 1e-10) return null;
    dir.x /= dirLen; dir.y /= dirLen; dir.z /= dirLen;

    // Test ray against all triangles
    let closestT = Infinity;
    let closestFaceIndex = -1;
    let closestPoint = null;

    const triData = this._meshTriangles;
    const triCount = this._meshTriangleCount / 3; // number of triangles
    for (let ti = 0; ti < triCount; ti++) {
      const base = ti * 3 * 6; // 3 vertices * 6 floats each
      const v0 = { x: triData[base], y: triData[base + 1], z: triData[base + 2] };
      const v1 = { x: triData[base + 6], y: triData[base + 7], z: triData[base + 8] };
      const v2 = { x: triData[base + 12], y: triData[base + 13], z: triData[base + 14] };

      const t = this._rayTriangleIntersect(origin, dir, v0, v1, v2);
      if (t !== null && t > 0 && t < closestT) {
        closestT = t;
        closestFaceIndex = this._triFaceMap ? this._triFaceMap[ti] : -1;
        closestPoint = {
          x: origin.x + dir.x * t,
          y: origin.y + dir.y * t,
          z: origin.z + dir.z * t,
        };
      }
    }

    if (closestFaceIndex >= 0 && closestPoint) {
      return {
        faceIndex: closestFaceIndex,
        face: this._meshFaces[closestFaceIndex],
        point: closestPoint,
      };
    }
    return null;
  }

  /**
   * Select a face by index for highlighting. Pass -1 to clear selection.
   * @param {number} faceIndex
   */
  selectFace(faceIndex) {
    this._selectedFaceIndex = faceIndex;
  }

  /**
   * Get the currently selected face index.
   * @returns {number} face index or -1 if none
   */
  getSelectedFaceIndex() {
    return this._selectedFaceIndex;
  }

  /** Möller–Trumbore ray-triangle intersection */
  _rayTriangleIntersect(origin, dir, v0, v1, v2) {
    const EPSILON = 1e-8;
    const e1 = { x: v1.x - v0.x, y: v1.y - v0.y, z: v1.z - v0.z };
    const e2 = { x: v2.x - v0.x, y: v2.y - v0.y, z: v2.z - v0.z };
    const h = {
      x: dir.y * e2.z - dir.z * e2.y,
      y: dir.z * e2.x - dir.x * e2.z,
      z: dir.x * e2.y - dir.y * e2.x,
    };
    const a = e1.x * h.x + e1.y * h.y + e1.z * h.z;
    if (a > -EPSILON && a < EPSILON) return null;
    const f = 1.0 / a;
    const s = { x: origin.x - v0.x, y: origin.y - v0.y, z: origin.z - v0.z };
    const u = f * (s.x * h.x + s.y * h.y + s.z * h.z);
    if (u < 0 || u > 1) return null;
    const q = {
      x: s.y * e1.z - s.z * e1.y,
      y: s.z * e1.x - s.x * e1.z,
      z: s.x * e1.y - s.y * e1.x,
    };
    const v = f * (dir.x * q.x + dir.y * q.y + dir.z * q.z);
    if (v < 0 || u + v > 1) return null;
    const t = f * (e2.x * q.x + e2.y * q.y + e2.z * q.z);
    return t > EPSILON ? t : null;
  }

  /** Invert a 4x4 column-major matrix */
  _mat4Invert(m) {
    const out = new Float32Array(16);
    const m00 = m[0], m01 = m[1], m02 = m[2], m03 = m[3];
    const m10 = m[4], m11 = m[5], m12 = m[6], m13 = m[7];
    const m20 = m[8], m21 = m[9], m22 = m[10], m23 = m[11];
    const m30 = m[12], m31 = m[13], m32 = m[14], m33 = m[15];

    const b00 = m00 * m11 - m01 * m10;
    const b01 = m00 * m12 - m02 * m10;
    const b02 = m00 * m13 - m03 * m10;
    const b03 = m01 * m12 - m02 * m11;
    const b04 = m01 * m13 - m03 * m11;
    const b05 = m02 * m13 - m03 * m12;
    const b06 = m20 * m31 - m21 * m30;
    const b07 = m20 * m32 - m22 * m30;
    const b08 = m20 * m33 - m23 * m30;
    const b09 = m21 * m32 - m22 * m31;
    const b10 = m21 * m33 - m23 * m31;
    const b11 = m22 * m33 - m23 * m32;

    let det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
    if (Math.abs(det) < 1e-10) return null;
    det = 1.0 / det;

    out[0]  = ( m11 * b11 - m12 * b10 + m13 * b09) * det;
    out[1]  = (-m01 * b11 + m02 * b10 - m03 * b09) * det;
    out[2]  = ( m31 * b05 - m32 * b04 + m33 * b03) * det;
    out[3]  = (-m21 * b05 + m22 * b04 - m23 * b03) * det;
    out[4]  = (-m10 * b11 + m12 * b08 - m13 * b07) * det;
    out[5]  = ( m00 * b11 - m02 * b08 + m03 * b07) * det;
    out[6]  = (-m30 * b05 + m32 * b02 - m33 * b01) * det;
    out[7]  = ( m20 * b05 - m22 * b02 + m23 * b01) * det;
    out[8]  = ( m10 * b10 - m11 * b08 + m13 * b06) * det;
    out[9]  = (-m00 * b10 + m01 * b08 - m03 * b06) * det;
    out[10] = ( m30 * b04 - m31 * b02 + m33 * b00) * det;
    out[11] = (-m20 * b04 + m21 * b02 - m23 * b00) * det;
    out[12] = (-m10 * b09 + m11 * b07 - m12 * b06) * det;
    out[13] = ( m00 * b09 - m01 * b07 + m02 * b06) * det;
    out[14] = (-m30 * b03 + m31 * b01 - m32 * b00) * det;
    out[15] = ( m20 * b03 - m21 * b01 + m22 * b00) * det;
    return out;
  }

  /** Transform a vec4 by a 4x4 column-major matrix */
  _mat4TransformVec4(m, x, y, z, w) {
    return {
      x: m[0] * x + m[4] * y + m[8]  * z + m[12] * w,
      y: m[1] * x + m[5] * y + m[9]  * z + m[13] * w,
      z: m[2] * x + m[6] * y + m[10] * z + m[14] * w,
      w: m[3] * x + m[7] * y + m[11] * z + m[15] * w,
    };
  }

  /* ---------- mode switching ---------- */
  setMode(mode) {
    this.mode = mode;
    if (!this._ready) return;

    if (mode === '2d') {
      this.wasm.setCameraMode(0);
      // Reset ortho
      const w = this.canvas.width;
      const h = this.canvas.height;
      const aspect = w / h;
      const viewSize = 500;
      this._orthoBounds = {
        left: -viewSize * aspect,
        right: viewSize * aspect,
        bottom: -viewSize,
        top: viewSize,
      };
      this.wasm.setOrthoBounds(
        this._orthoBounds.left, this._orthoBounds.right,
        this._orthoBounds.bottom, this._orthoBounds.top
      );
      this.wasm.setCameraPosition(0, 0, 500);
      this.wasm.setCameraTarget(0, 0, 0);
      // Up must be (0,1,0) when looking down the Z axis to avoid
      // a degenerate lookAt matrix (up parallel to view direction).
      this.wasm.setCameraUp(0, 1, 0);
      this.wasm.setGridVisible(1);
      this.wasm.setAxesVisible(1);
    } else {
      this.wasm.setCameraMode(1);
      // Restore Z-up for 3D orbit camera
      this.wasm.setCameraUp(0, 0, 1);
      // Set a reasonable default grid for 3D mode
      this.wasm.setGridSize(200, 20);
      this.wasm.setAxesSize(50);
      // Apply orbit camera state
      this._orbitDirty = true;
      this._applyOrbitCamera();
      this.wasm.setGridVisible(1);
      this.wasm.setAxesVisible(1);
    }
  }

  setVisible(visible) {
    this.canvas.style.display = visible ? 'block' : 'none';
    this.overlayCanvas.style.display = visible ? 'block' : 'none';
  }

  onWindowResize() {
    const w = this.container.clientWidth;
    const h = this.container.clientHeight;
    if (w <= 0 || h <= 0) return;

    this.canvas.width = w;
    this.canvas.height = h;
    this.overlayCanvas.width = w;
    this.overlayCanvas.height = h;
    this.executor.resize(w, h);

    if (this._ready) {
      this.wasm.resize(w, h);
    }
  }

  /* ---------- 2D Sketch Rendering ---------- */

  /**
   * Sync orthographic camera to viewport pan/zoom.
   */
  sync2DView(viewport) {
    if (!viewport || !this._ready || this.mode !== '2d') return;

    const zoom = Math.max(0.0001, viewport.zoom || 1);
    const w = Math.max(1, viewport.width || this.canvas.width);
    const h = Math.max(1, viewport.height || this.canvas.height);

    const halfW = w / (2 * zoom);
    const halfH = h / (2 * zoom);

    const cx = -viewport.panX / zoom;
    const cy = viewport.panY / zoom;

    this._orthoBounds = { left: cx - halfW, right: cx + halfW, bottom: cy - halfH, top: cy + halfH };
    this._cameraPos = { x: cx, y: cy, z: 500 };

    this.wasm.setOrthoBounds(cx - halfW, cx + halfW, cy - halfH, cy + halfH);
    this.wasm.setCameraPosition(cx, cy, 500);
    this.wasm.setCameraTarget(cx, cy, 0);
    // Ensure up vector stays Y-up for 2D top-down view
    this.wasm.setCameraUp(0, 1, 0);
  }

  /**
   * Render 2D sketch entities.
   * Pushes entity data to WASM for GPU-accelerated rendering.
   * Text/dimension labels and constraint icons remain on the overlay canvas
   * since WebGL does not natively support text.
   */
  render2DScene(scene, overlays = {}) {
    if (!scene || !this._ready) return;

    const wasm = this.wasm;
    wasm.clearEntities();

    const isLayerVisible = overlays.isLayerVisible || (() => true);
    const getLayerColor = overlays.getLayerColor || (() => '#9CDCFE');
    const hoverEntity = overlays.hoverEntity || null;
    const previewEntities = overlays.previewEntities || [];
    const snapPoint = overlays.snapPoint || null;
    const cursorWorld = overlays.cursorWorld || null;
    const allDimensionsVisible = overlays.allDimensionsVisible !== false;
    const constraintIconsVisible = overlays.constraintIconsVisible !== false;

    // Entity flag constants
    const F_VISIBLE = 1;
    const F_SELECTED = 2;
    const F_CONSTRUCTION = 4;
    const F_HOVER = 8;
    const F_FIXED = 16;
    const F_PREVIEW = 32;

    const DEFAULT_COLOR = [0.612, 0.863, 0.996, 1.0]; // #9CDCFE

    const parseColor = (colorStr) => {
      if (!colorStr || typeof colorStr !== 'string') return DEFAULT_COLOR;
      if (colorStr.startsWith('#')) {
        const hex = colorStr.slice(1);
        if (hex.length === 6) {
          return [
            parseInt(hex.slice(0, 2), 16) / 255,
            parseInt(hex.slice(2, 4), 16) / 255,
            parseInt(hex.slice(4, 6), 16) / 255,
            1.0
          ];
        }
      }
      return DEFAULT_COLOR;
    };

    const entityColor = (entity) => {
      if (entity.selected) return [0, 0.749, 1, 1];
      if (entity.construction) return [0.565, 0.933, 0.565, 1];
      const c = entity.color || getLayerColor(entity.layer);
      return parseColor(c);
    };

    // --- Push segments to WASM ---
    if (scene.segments) {
      scene.segments.forEach((seg) => {
        if (!seg.visible || !isLayerVisible(seg.layer) || !seg.p1 || !seg.p2) return;
        let flags = F_VISIBLE;
        if (seg.selected) flags |= F_SELECTED;
        if (seg.construction) flags |= F_CONSTRUCTION;
        if (hoverEntity && hoverEntity.id === seg.id) flags |= F_HOVER;
        const [r, g, b, a] = entityColor(seg);
        wasm.addEntitySegment(seg.p1.x, seg.p1.y, seg.p2.x, seg.p2.y, flags, r, g, b, a);
      });
    }

    // --- Push circles to WASM ---
    if (scene.circles) {
      scene.circles.forEach((circle) => {
        if (!circle.visible || !isLayerVisible(circle.layer)) return;
        let flags = F_VISIBLE;
        if (circle.selected) flags |= F_SELECTED;
        if (circle.construction) flags |= F_CONSTRUCTION;
        if (hoverEntity && hoverEntity.id === circle.id) flags |= F_HOVER;
        const [r, g, b, a] = entityColor(circle);
        wasm.addEntityCircle(circle.center.x, circle.center.y, circle.radius, flags, r, g, b, a);
      });
    }

    // --- Push arcs to WASM ---
    if (scene.arcs) {
      scene.arcs.forEach((arc) => {
        if (!arc.visible || !isLayerVisible(arc.layer)) return;
        let flags = F_VISIBLE;
        if (arc.selected) flags |= F_SELECTED;
        if (arc.construction) flags |= F_CONSTRUCTION;
        if (hoverEntity && hoverEntity.id === arc.id) flags |= F_HOVER;
        const [r, g, b, a] = entityColor(arc);
        wasm.addEntityArc(arc.center.x, arc.center.y, arc.radius, arc.startAngle, arc.endAngle, flags, r, g, b, a);
      });
    }

    // --- Push points to WASM ---
    if (scene.points) {
      scene.points.forEach((point) => {
        const refs = scene.shapesUsingPoint ? scene.shapesUsingPoint(point).length : 1;
        const isHover = hoverEntity && hoverEntity.id === point.id;
        if (refs <= 1 && !point.selected && !point.fixed && !isHover) return;
        let flags = F_VISIBLE;
        if (point.selected) flags |= F_SELECTED;
        if (isHover) flags |= F_HOVER;
        if (point.fixed) flags |= F_FIXED;
        const size = point.selected ? 7 : (isHover ? 6 : (point.fixed ? 5 : 4));
        const [r, g, b, a] = point.selected ? [0, 0.749, 1, 1]
          : (isHover ? [0.498, 0.847, 1, 1]
            : (point.fixed ? [1, 0.4, 0.267, 1]
              : [1, 1, 0.4, 1]));
        wasm.addEntityPoint(point.x, point.y, size, flags, r, g, b, a);
      });
    }

    // --- Push preview entities to WASM ---
    if (previewEntities && previewEntities.length > 0) {
      previewEntities.forEach((entity) => {
        if (!entity) return;
        const flags = F_VISIBLE | F_PREVIEW;
        if (entity.type === 'segment' && entity.p1 && entity.p2) {
          wasm.addEntitySegment(entity.p1.x, entity.p1.y, entity.p2.x, entity.p2.y, flags, 0, 0.749, 1, 1);
        } else if (entity.type === 'circle' && entity.center) {
          wasm.addEntityCircle(entity.center.x, entity.center.y, entity.radius, flags, 0, 0.749, 1, 1);
        } else if (entity.type === 'arc' && entity.center) {
          wasm.addEntityArc(entity.center.x, entity.center.y, entity.radius, entity.startAngle, entity.endAngle, flags, 0, 0.749, 1, 1);
        }
      });
    }

    // --- Snap point ---
    if (snapPoint) {
      wasm.setSnapPosition(snapPoint.x, snapPoint.y, 1);
    } else {
      wasm.setSnapPosition(0, 0, 0);
    }

    // --- Cursor crosshair ---
    if (cursorWorld && this.mode === '2d') {
      wasm.setCursorPosition(cursorWorld.x, cursorWorld.y, 1);
    } else {
      wasm.setCursorPosition(0, 0, 0);
    }

    // --- Overlay canvas for text-based elements (dimensions, constraint icons) ---
    const ctx = this.overlayCtx;
    const w = this.overlayCanvas.width;
    const h = this.overlayCanvas.height;
    ctx.clearRect(0, 0, w, h);

    const bounds = this._orthoBounds;
    const worldToScreenX = (wx) => ((wx - bounds.left) / (bounds.right - bounds.left)) * w;
    const worldToScreenY = (wy) => ((bounds.top - wy) / (bounds.top - bounds.bottom)) * h;
    const wpp = (bounds.right - bounds.left) / w;

    // --- Dimensions (text overlay) ---
    if (allDimensionsVisible && scene.dimensions) {
      scene.dimensions.forEach((dim) => {
        if (!dim.visible || !isLayerVisible(dim.layer)) return;
        const isHover = hoverEntity && hoverEntity.id === dim.id;
        const dimColor = dim.selected ? '#00bfff' : (isHover ? '#7fd8ff' : (!dim.isConstraint ? '#ffb432' : (dim.color || getLayerColor(dim.layer))));
        ctx.strokeStyle = dimColor;
        ctx.fillStyle = dimColor;
        ctx.lineWidth = 1;
        ctx.setLineDash([]);

        if (dim.dimType === 'angle') {
          const r = Math.abs(dim.offset) / wpp;
          const startA = dim._angleStart != null ? dim._angleStart : 0;
          const sweepA = dim._angleSweep != null ? dim._angleSweep : 0;
          const cx = worldToScreenX(dim.x1);
          const cy = worldToScreenY(dim.y1);
          ctx.beginPath();
          ctx.arc(cx, cy, r, -startA, -(startA + sweepA), true);
          ctx.stroke();
          const midA = startA + sweepA / 2;
          const lx = worldToScreenX(dim.x1 + (Math.abs(dim.offset) + 14 * wpp) * Math.cos(midA));
          const ly = worldToScreenY(dim.y1 + (Math.abs(dim.offset) + 14 * wpp) * Math.sin(midA));
          ctx.font = '12px Consolas, monospace';
          ctx.textBaseline = 'middle';
          ctx.fillText(dim.displayLabel || '', lx, ly);
          return;
        }

        const dx = dim.x2 - dim.x1;
        const dy = dim.y2 - dim.y1;
        const len = Math.hypot(dx, dy) || 1e-9;
        const nx = -dy / len, ny = dx / len;
        let d1, d2;

        if (dim.dimType === 'dx') {
          const dimY = dim.y1 + dim.offset;
          d1 = { x: dim.x1, y: dimY };
          d2 = { x: dim.x2, y: dimY };
        } else if (dim.dimType === 'dy') {
          const dimX = dim.x1 + dim.offset;
          d1 = { x: dimX, y: dim.y1 };
          d2 = { x: dimX, y: dim.y2 };
        } else {
          d1 = { x: dim.x1 + nx * dim.offset, y: dim.y1 + ny * dim.offset };
          d2 = { x: dim.x2 + nx * dim.offset, y: dim.y2 + ny * dim.offset };
        }

        ctx.beginPath();
        ctx.moveTo(worldToScreenX(dim.x1), worldToScreenY(dim.y1));
        ctx.lineTo(worldToScreenX(d1.x), worldToScreenY(d1.y));
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(worldToScreenX(dim.x2), worldToScreenY(dim.y2));
        ctx.lineTo(worldToScreenX(d2.x), worldToScreenY(d2.y));
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(worldToScreenX(d1.x), worldToScreenY(d1.y));
        ctx.lineTo(worldToScreenX(d2.x), worldToScreenY(d2.y));
        ctx.stroke();

        const mx = (d1.x + d2.x) / 2;
        const my = (d1.y + d2.y) / 2 + 12 * wpp;
        ctx.font = '12px Consolas, monospace';
        ctx.textBaseline = 'middle';
        ctx.textAlign = 'center';
        ctx.fillText(dim.displayLabel || '', worldToScreenX(mx), worldToScreenY(my));
        ctx.textAlign = 'left';
      });
    }

    // --- Texts ---
    if (scene.texts) {
      scene.texts.forEach((text) => {
        if (!text.visible || !isLayerVisible(text.layer)) return;
        const color = text.selected ? '#00bfff' : (text.color || getLayerColor(text.layer));
        ctx.fillStyle = color;
        ctx.font = '14px Consolas, monospace';
        ctx.textBaseline = 'middle';
        const sx = worldToScreenX(text.x);
        const sy = worldToScreenY(text.y);
        ctx.save();
        ctx.translate(sx, sy);
        if (text.rotation) ctx.rotate(-text.rotation * Math.PI / 180);
        ctx.fillText(text.text, 0, 0);
        ctx.restore();
      });
    }

    // --- Sketch plane reference axes (colored, from origin) ---
    if (this._sketchPlane) {
      const axisLen = Math.max(bounds.right - bounds.left, bounds.top - bounds.bottom) * 0.6;
      const ox = worldToScreenX(0);
      const oy = worldToScreenY(0);

      // Determine axis labels and colors based on the sketch plane
      let hLabel, vLabel, hColor, vColor;
      switch (this._sketchPlane) {
        case 'XY': hLabel = 'X'; vLabel = 'Y'; hColor = '#ff4444'; vColor = '#44ff44'; break;
        case 'XZ': hLabel = 'X'; vLabel = 'Z'; hColor = '#ff4444'; vColor = '#4488ff'; break;
        case 'YZ': hLabel = 'Y'; vLabel = 'Z'; hColor = '#44ff44'; vColor = '#4488ff'; break;
        default:   hLabel = 'X'; vLabel = 'Y'; hColor = '#ff4444'; vColor = '#44ff44'; break;
      }

      // Horizontal axis (positive direction to the right)
      const hEndX = worldToScreenX(axisLen);
      ctx.save();
      ctx.strokeStyle = hColor;
      ctx.lineWidth = 1.5;
      ctx.globalAlpha = 0.6;
      ctx.setLineDash([]);
      ctx.beginPath();
      ctx.moveTo(ox, oy);
      ctx.lineTo(hEndX, oy);
      ctx.stroke();
      // Arrow
      ctx.beginPath();
      ctx.moveTo(hEndX, oy);
      ctx.lineTo(hEndX - 8, oy - 4);
      ctx.moveTo(hEndX, oy);
      ctx.lineTo(hEndX - 8, oy + 4);
      ctx.stroke();
      // Label
      ctx.globalAlpha = 0.8;
      ctx.fillStyle = hColor;
      ctx.font = 'bold 13px Consolas, monospace';
      ctx.textBaseline = 'middle';
      ctx.textAlign = 'left';
      ctx.fillText(hLabel, hEndX + 4, oy);
      ctx.restore();

      // Vertical axis (positive direction upward)
      const vEndY = worldToScreenY(axisLen);
      ctx.save();
      ctx.strokeStyle = vColor;
      ctx.lineWidth = 1.5;
      ctx.globalAlpha = 0.6;
      ctx.setLineDash([]);
      ctx.beginPath();
      ctx.moveTo(ox, oy);
      ctx.lineTo(ox, vEndY);
      ctx.stroke();
      // Arrow
      ctx.beginPath();
      ctx.moveTo(ox, vEndY);
      ctx.lineTo(ox - 4, vEndY + 8);
      ctx.moveTo(ox, vEndY);
      ctx.lineTo(ox + 4, vEndY + 8);
      ctx.stroke();
      // Label
      ctx.globalAlpha = 0.8;
      ctx.fillStyle = vColor;
      ctx.font = 'bold 13px Consolas, monospace';
      ctx.textBaseline = 'bottom';
      ctx.textAlign = 'center';
      ctx.fillText(vLabel, ox, vEndY - 4);
      ctx.restore();

      // Origin marker
      ctx.save();
      ctx.fillStyle = '#ffffff';
      ctx.globalAlpha = 0.7;
      ctx.beginPath();
      ctx.arc(ox, oy, 3, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();
    }

    // --- Constraint icons ---
    if (constraintIconsVisible && scene.constraints) {
      const iconMap = {
        coincident: '⊙', distance: '↔', fixed: '⊕',
        horizontal: 'H', vertical: 'V', parallel: '∥', perpendicular: '⊥',
        angle: '∠', equal_length: '=', length: 'L', radius: 'R', tangent: 'T',
        on_line: '—·', on_circle: '○·', midpoint: 'M',
      };
      scene.constraints.forEach((constraint) => {
        if (constraint.type === 'dimension') return;
        if (typeof constraint.involvedPoints !== 'function') return;
        const pts = constraint.involvedPoints();
        if (!pts || pts.length === 0) return;
        let cx = 0, cy = 0;
        for (const p of pts) { cx += p.x; cy += p.y; }
        cx /= pts.length; cy /= pts.length;
        const icon = iconMap[constraint.type] || '?';
        const ok = (typeof constraint.error === 'function') ? constraint.error() < 1e-4 : false;
        ctx.fillStyle = ok ? '#00e676' : '#ff643c';
        ctx.font = '13px Consolas, monospace';
        ctx.fillText(icon, worldToScreenX(cx + 12 * wpp), worldToScreenY(cy + 10 * wpp));
      });
    }
  }

  /* ---------- 3D Part Rendering ---------- */

  renderPart(part) {
    this.clearPartGeometry();
    if (!part || !this._ready) return;

    const geo = part.getFinalGeometry();
    if (!geo) return;

    if (geo.type === 'solid' && geo.geometry) {
      const bb = geo.boundingBox;
      if (bb) this._partBounds = bb;

      // Build actual mesh from geometry faces
      this._buildMeshFromGeometry(geo.geometry);
    }

    // Build sketch wireframes for all sketch features (visible in 3D mode)
    this._buildSketchWireframes(part);
  }

  /**
   * Triangulate polygon faces and build Float32Arrays for WebGL rendering.
   * Stores face metadata for selection/identification.
   */
  _buildMeshFromGeometry(geometry) {
    const faces = geometry.faces || [];

    // Store face metadata for selection
    this._meshFaces = faces.map((face, idx) => ({
      index: idx,
      faceType: face.faceType || 'unknown',
      normal: face.normal || { x: 0, y: 0, z: 1 },
      shared: face.shared || null,
      vertexCount: face.vertices.length,
    }));

    // Count triangles needed (fan triangulation: n-gon → n-2 triangles)
    let triCount = 0;
    for (const face of faces) {
      if (face.vertices.length >= 3) {
        triCount += face.vertices.length - 2;
      }
    }

    // Build interleaved triangle data: [x,y,z,nx,ny,nz] per vertex
    const triData = new Float32Array(triCount * 3 * 6);
    let ti = 0;

    // Map triangle index → face index for hit testing
    this._triFaceMap = new Int32Array(triCount);
    let triIdx = 0;

    for (let fi = 0; fi < faces.length; fi++) {
      const face = faces[fi];
      const verts = face.vertices;
      const n = face.normal || { x: 0, y: 0, z: 1 };
      if (verts.length < 3) continue;

      // Fan triangulation from vertex 0
      for (let i = 1; i < verts.length - 1; i++) {
        const v0 = verts[0], v1 = verts[i], v2 = verts[i + 1];
        triData[ti++] = v0.x; triData[ti++] = v0.y; triData[ti++] = v0.z;
        triData[ti++] = n.x;  triData[ti++] = n.y;  triData[ti++] = n.z;
        triData[ti++] = v1.x; triData[ti++] = v1.y; triData[ti++] = v1.z;
        triData[ti++] = n.x;  triData[ti++] = n.y;  triData[ti++] = n.z;
        triData[ti++] = v2.x; triData[ti++] = v2.y; triData[ti++] = v2.z;
        triData[ti++] = n.x;  triData[ti++] = n.y;  triData[ti++] = n.z;
        this._triFaceMap[triIdx++] = fi;
      }
    }

    this._meshTriangles = triData;
    this._meshTriangleCount = triCount * 3; // vertex count

    // Use deduplicated edges from CSG if available, otherwise compute feature edges
    if (geometry.edges && geometry.edges.length > 0) {
      const edgeData = new Float32Array(geometry.edges.length * 2 * 3);
      let ei = 0;
      for (const edge of geometry.edges) {
        edgeData[ei++] = edge.start.x; edgeData[ei++] = edge.start.y; edgeData[ei++] = edge.start.z;
        edgeData[ei++] = edge.end.x;   edgeData[ei++] = edge.end.y;   edgeData[ei++] = edge.end.z;
      }
      this._meshEdges = edgeData;
      this._meshEdgeVertexCount = geometry.edges.length * 2;
    } else {
      // Compute feature edges: only show edges where adjacent faces have different normals
      const SHARP_COS = Math.cos(15 * Math.PI / 180);
      const edgeMap = new Map();
      const precision = 5;
      const vKey = (v) => `${v.x.toFixed(precision)},${v.y.toFixed(precision)},${v.z.toFixed(precision)}`;
      const eKey = (a, b) => { const ka = vKey(a), kb = vKey(b); return ka < kb ? `${ka}|${kb}` : `${kb}|${ka}`; };

      for (const face of faces) {
        const verts = face.vertices;
        const n = face.normal || { x: 0, y: 0, z: 1 };
        for (let i = 0; i < verts.length; i++) {
          const a = verts[i], b = verts[(i + 1) % verts.length];
          const key = eKey(a, b);
          if (!edgeMap.has(key)) {
            edgeMap.set(key, { a, b, normals: [] });
          }
          edgeMap.get(key).normals.push(n);
        }
      }

      const featureEdges = [];
      for (const [, info] of edgeMap) {
        if (info.normals.length === 1) {
          featureEdges.push(info);
        } else if (info.normals.length >= 2) {
          const n0 = info.normals[0];
          for (let i = 1; i < info.normals.length; i++) {
            const n1 = info.normals[i];
            const dot = n0.x * n1.x + n0.y * n1.y + n0.z * n1.z;
            if (dot < SHARP_COS) { featureEdges.push(info); break; }
          }
        }
      }

      const edgeData = new Float32Array(featureEdges.length * 2 * 3);
      let ei = 0;
      for (const e of featureEdges) {
        edgeData[ei++] = e.a.x; edgeData[ei++] = e.a.y; edgeData[ei++] = e.a.z;
        edgeData[ei++] = e.b.x; edgeData[ei++] = e.b.y; edgeData[ei++] = e.b.z;
      }
      this._meshEdges = edgeData;
      this._meshEdgeVertexCount = featureEdges.length * 2;
    }
  }

  /**
   * Build wireframe data for sketch features so they are visible in 3D Part mode.
   * Transforms 2D sketch primitives to 3D world coordinates using their plane definitions.
   * @param {Object} part - The Part object containing sketch features
   */
  _buildSketchWireframes(part) {
    this._sketchEdges = null;
    this._sketchEdgeVertexCount = 0;

    const sketches = part.getSketches();
    if (!sketches || sketches.length === 0) return;

    const lines = [];

    for (const sketchFeature of sketches) {
      if (sketchFeature.suppressed) continue;
      const sketch = sketchFeature.sketch;
      const plane = sketchFeature.plane;
      if (!sketch || !plane) continue;

      const toWorld = (px, py) => ({
        x: plane.origin.x + px * plane.xAxis.x + py * plane.yAxis.x,
        y: plane.origin.y + px * plane.xAxis.y + py * plane.yAxis.y,
        z: plane.origin.z + px * plane.xAxis.z + py * plane.yAxis.z,
      });

      // Segments
      if (sketch.segments) {
        for (const seg of sketch.segments) {
          if (!seg.visible || !seg.p1 || !seg.p2) continue;
          const a = toWorld(seg.p1.x, seg.p1.y);
          const b = toWorld(seg.p2.x, seg.p2.y);
          lines.push(a.x, a.y, a.z, b.x, b.y, b.z);
        }
      }

      // Circles (approximate with line segments)
      if (sketch.circles) {
        for (const circle of sketch.circles) {
          if (!circle.visible || !circle.center) continue;
          const numSegs = 32;
          for (let i = 0; i < numSegs; i++) {
            const a1 = (i / numSegs) * Math.PI * 2;
            const a2 = ((i + 1) / numSegs) * Math.PI * 2;
            const p1 = toWorld(
              circle.center.x + Math.cos(a1) * circle.radius,
              circle.center.y + Math.sin(a1) * circle.radius
            );
            const p2 = toWorld(
              circle.center.x + Math.cos(a2) * circle.radius,
              circle.center.y + Math.sin(a2) * circle.radius
            );
            lines.push(p1.x, p1.y, p1.z, p2.x, p2.y, p2.z);
          }
        }
      }

      // Arcs (approximate with line segments)
      if (sketch.arcs) {
        for (const arc of sketch.arcs) {
          if (!arc.visible || !arc.center) continue;
          const numSegs = 16;
          let startA = arc.startAngle || 0;
          let endA = arc.endAngle || Math.PI;
          let sweep = endA - startA;
          if (sweep < 0) sweep += Math.PI * 2;
          for (let i = 0; i < numSegs; i++) {
            const a1 = startA + (i / numSegs) * sweep;
            const a2 = startA + ((i + 1) / numSegs) * sweep;
            const p1 = toWorld(
              arc.center.x + Math.cos(a1) * arc.radius,
              arc.center.y + Math.sin(a1) * arc.radius
            );
            const p2 = toWorld(
              arc.center.x + Math.cos(a2) * arc.radius,
              arc.center.y + Math.sin(a2) * arc.radius
            );
            lines.push(p1.x, p1.y, p1.z, p2.x, p2.y, p2.z);
          }
        }
      }
    }

    if (lines.length > 0) {
      this._sketchEdges = new Float32Array(lines);
      this._sketchEdgeVertexCount = lines.length / 3;
    }
  }

  /**
   * Render pre-built mesh data directly via WebGL (called after WASM render pass).
   */
  _renderMeshOverlay() {
    const gl = this.executor.gl;
    const exec = this.executor;
    const hasMesh = this._meshTriangles && this._meshTriangleCount > 0;
    const hasSketchEdges = this._sketchEdges && this._sketchEdgeVertexCount > 0;
    if (!hasMesh && !hasSketchEdges) return;

    // Compute the same MVP as the WASM camera
    const mvp = this._computeMVP();
    if (!mvp) return;

    // Enable depth testing and backface culling for correct solid rendering
    gl.enable(gl.DEPTH_TEST);
    gl.depthFunc(gl.LEQUAL);
    gl.enable(gl.CULL_FACE);
    gl.cullFace(gl.BACK);

    if (hasMesh) {
      // Draw solid triangles with polygon offset to avoid z-fighting with edges
      gl.enable(gl.POLYGON_OFFSET_FILL);
      gl.polygonOffset(1.0, 1.0);

      gl.useProgram(exec.programs[0]);
      gl.uniformMatrix4fv(exec.uniforms[0].uMVP, false, mvp);
      gl.uniform4f(exec.uniforms[0].uColor, 0.65, 0.75, 0.65, 1.0);

      gl.bindVertexArray(exec.vaoSolid);
      gl.bindBuffer(gl.ARRAY_BUFFER, exec.vbo);
      gl.bufferData(gl.ARRAY_BUFFER, this._meshTriangles, gl.DYNAMIC_DRAW);
      gl.drawArrays(gl.TRIANGLES, 0, this._meshTriangleCount);
      gl.bindVertexArray(null);

      gl.disable(gl.POLYGON_OFFSET_FILL);

      // Draw selected face highlight
      if (this._selectedFaceIndex >= 0 && this._meshFaces && this._triFaceMap) {
        // Build highlight triangles for the selected face
        const highlightVerts = [];
        const triCount = this._meshTriangleCount / 3;
        for (let ti = 0; ti < triCount; ti++) {
          if (this._triFaceMap[ti] === this._selectedFaceIndex) {
            const base = ti * 3 * 6;
            for (let vi = 0; vi < 3; vi++) {
              const vbase = base + vi * 6;
              highlightVerts.push(
                this._meshTriangles[vbase], this._meshTriangles[vbase + 1], this._meshTriangles[vbase + 2],
                this._meshTriangles[vbase + 3], this._meshTriangles[vbase + 4], this._meshTriangles[vbase + 5]
              );
            }
          }
        }
        if (highlightVerts.length > 0) {
          gl.enable(gl.BLEND);
          gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
          gl.depthFunc(gl.LEQUAL);
          gl.disable(gl.CULL_FACE);

          const highlightData = new Float32Array(highlightVerts);
          gl.useProgram(exec.programs[0]);
          gl.uniformMatrix4fv(exec.uniforms[0].uMVP, false, mvp);
          gl.uniform4f(exec.uniforms[0].uColor, 0.2, 0.6, 1.0, 0.35);

          gl.bindVertexArray(exec.vaoSolid);
          gl.bindBuffer(gl.ARRAY_BUFFER, exec.vbo);
          gl.bufferData(gl.ARRAY_BUFFER, highlightData, gl.DYNAMIC_DRAW);
          gl.drawArrays(gl.TRIANGLES, 0, highlightVerts.length / 6);
          gl.bindVertexArray(null);

          gl.disable(gl.BLEND);
          gl.enable(gl.CULL_FACE);
          gl.cullFace(gl.BACK);
        }
      }

      // Draw feature wireframe edges
      if (this._meshEdges && this._meshEdgeVertexCount > 0) {
        gl.useProgram(exec.programs[1]);
        gl.uniformMatrix4fv(exec.uniforms[1].uMVP, false, mvp);
        gl.uniform4f(exec.uniforms[1].uColor, 0.1, 0.1, 0.1, 1.0);
        gl.lineWidth(1.0);

        gl.bindVertexArray(exec.vaoLine);
        gl.bindBuffer(gl.ARRAY_BUFFER, exec.vbo);
        gl.bufferData(gl.ARRAY_BUFFER, this._meshEdges, gl.DYNAMIC_DRAW);
        gl.drawArrays(gl.LINES, 0, this._meshEdgeVertexCount);
        gl.bindVertexArray(null);
      }
    }

    // Draw sketch wireframes (visible sketch primitives in 3D)
    if (hasSketchEdges) {
      gl.disable(gl.CULL_FACE);
      gl.useProgram(exec.programs[1]);
      gl.uniformMatrix4fv(exec.uniforms[1].uMVP, false, mvp);
      gl.uniform4f(exec.uniforms[1].uColor, 0.4, 0.7, 1.0, 1.0);
      gl.lineWidth(1.0);

      gl.bindVertexArray(exec.vaoLine);
      gl.bindBuffer(gl.ARRAY_BUFFER, exec.vbo);
      gl.bufferData(gl.ARRAY_BUFFER, this._sketchEdges, gl.DYNAMIC_DRAW);
      gl.drawArrays(gl.LINES, 0, this._sketchEdgeVertexCount);
      gl.bindVertexArray(null);
    }

    gl.disable(gl.CULL_FACE);
  }

  /**
   * Compute MVP matrix matching the current WASM perspective camera.
   */
  _computeMVP() {
    const w = this.canvas.width;
    const h = this.canvas.height;
    if (w === 0 || h === 0) return null;

    const aspect = w / h;
    const fov = Math.PI / 4;
    const near = 0.1;
    const far = 10000;
    const t = this._orbitTarget;
    const theta = this._orbitTheta;
    const phi = this._orbitPhi;
    const r = this._orbitRadius;

    const camX = t.x + r * Math.sin(phi) * Math.cos(theta);
    const camY = t.y + r * Math.sin(phi) * Math.sin(theta);
    const camZ = t.z + r * Math.cos(phi);

    // View matrix (lookAt with Z-up)
    const view = this._mat4LookAt(camX, camY, camZ, t.x, t.y, t.z, 0, 0, 1);
    if (!view) return null;
    // Projection matrix (perspective)
    const proj = this._mat4Perspective(fov, aspect, near, far);
    // MVP = proj * view (column-major multiplication)
    return this._mat4Multiply(proj, view);
  }

  _mat4Perspective(fov, aspect, near, far) {
    const f = 1.0 / Math.tan(fov / 2);
    const nf = 1 / (near - far);
    return new Float32Array([
      f / aspect, 0, 0, 0,
      0, f, 0, 0,
      0, 0, (far + near) * nf, -1,
      0, 0, 2 * far * near * nf, 0,
    ]);
  }

  _mat4LookAt(ex, ey, ez, cx, cy, cz, ux, uy, uz) {
    let fx = cx - ex, fy = cy - ey, fz = cz - ez;
    let len = Math.sqrt(fx * fx + fy * fy + fz * fz);
    if (len < 1e-10) return null;
    fx /= len; fy /= len; fz /= len;

    // s = f × up
    let sx = fy * uz - fz * uy, sy = fz * ux - fx * uz, sz = fx * uy - fy * ux;
    len = Math.sqrt(sx * sx + sy * sy + sz * sz);
    if (len < 1e-10) {
      // Forward parallel to up — use alternative up vector
      const ax = Math.abs(fx) < 0.9 ? 1 : 0, ay = Math.abs(fx) < 0.9 ? 0 : 1;
      sx = fy * 0 - fz * ay; sy = fz * ax - fx * 0; sz = fx * ay - fy * ax;
      len = Math.sqrt(sx * sx + sy * sy + sz * sz);
      if (len < 1e-10) return null;
    }
    sx /= len; sy /= len; sz /= len;

    // u = s × f
    const ux2 = sy * fz - sz * fy, uy2 = sz * fx - sx * fz, uz2 = sx * fy - sy * fx;

    return new Float32Array([
      sx, ux2, -fx, 0,
      sy, uy2, -fy, 0,
      sz, uz2, -fz, 0,
      -(sx * ex + sy * ey + sz * ez),
      -(ux2 * ex + uy2 * ey + uz2 * ez),
      (fx * ex + fy * ey + fz * ez),
      1,
    ]);
  }

  _mat4Multiply(a, b) {
    const out = new Float32Array(16);
    for (let i = 0; i < 4; i++) {
      for (let j = 0; j < 4; j++) {
        out[j * 4 + i] =
          a[0 * 4 + i] * b[j * 4 + 0] +
          a[1 * 4 + i] * b[j * 4 + 1] +
          a[2 * 4 + i] * b[j * 4 + 2] +
          a[3 * 4 + i] * b[j * 4 + 3];
      }
    }
    return out;
  }

  clearPartGeometry() {
    if (!this._ready) return;
    for (const id of this._partNodes) {
      this.wasm.removeNode(id);
    }
    this._partNodes = [];
    this._partBounds = null;
    this._meshTriangles = null;
    this._meshTriangleCount = 0;
    this._meshEdges = null;
    this._meshEdgeVertexCount = 0;
    this._meshFaces = null;
    this._triFaceMap = null;
    this._sketchEdges = null;
    this._sketchEdgeVertexCount = 0;
    this._selectedFaceIndex = -1;
  }

  /**
   * Get face metadata for a given face index.
   * @param {number} faceIndex - Index into the faces array
   * @returns {Object|null} Face metadata (faceType, normal, shared)
   */
  getFaceInfo(faceIndex) {
    if (!this._meshFaces || faceIndex < 0 || faceIndex >= this._meshFaces.length) return null;
    return this._meshFaces[faceIndex];
  }

  /**
   * Get all face metadata.
   * @returns {Array|null} Array of face metadata objects
   */
  getAllFaces() {
    return this._meshFaces || null;
  }

  clearGeometry() {
    this.clearPartGeometry();
    if (this._ready) {
      this.wasm.clearScene();
    }
  }

  fitToView() {
    if (!this._ready) return;
    if (this.mode === '3d') {
      const bb = this._partBounds;
      if (bb) {
        // Center the camera on the part
        const cx = (bb.max.x + bb.min.x) / 2;
        const cy = (bb.max.y + bb.min.y) / 2;
        const cz = (bb.max.z + bb.min.z) / 2;
        this._orbitTarget = { x: cx, y: cy, z: cz };

        // Compute radius to fit the part in view
        const sx = bb.max.x - bb.min.x;
        const sy = bb.max.y - bb.min.y;
        const sz = bb.max.z - bb.min.z;
        const maxDim = Math.max(sx, sy, sz, 10);
        this._orbitRadius = maxDim * 2.5;

        // Scale grid and axes to match the part scale
        this.wasm.setGridSize(maxDim * 3, 20);
        this.wasm.setAxesSize(maxDim * 0.5);
      } else {
        this._orbitTarget = { x: 0, y: 0, z: 0 };
        this._orbitRadius = 500;
      }
      this._orbitTheta = Math.PI / 4;
      this._orbitPhi = Math.PI / 3;
      this._orbitDirty = true;
      this._applyOrbitCamera();
    }
  }

  /**
   * Convert screen coordinates to world coordinates on the XY plane.
   */
  screenToWorld(screenX, screenY) {
    const rect = this.canvas.getBoundingClientRect();
    const ndcX = ((screenX - rect.left) / rect.width) * 2 - 1;
    const ndcY = -((screenY - rect.top) / rect.height) * 2 + 1;

    const bounds = this._orthoBounds;
    const wx = bounds.left + (ndcX + 1) * 0.5 * (bounds.right - bounds.left);
    const wy = bounds.bottom + (ndcY + 1) * 0.5 * (bounds.top - bounds.bottom);
    return { x: wx, y: wy };
  }

  dispose() {
    if (this._animationId) {
      cancelAnimationFrame(this._animationId);
    }
    this.clearGeometry();
    this.executor.dispose();
    if (this._resizeHandler) {
      window.removeEventListener('resize', this._resizeHandler);
    }
    if (this.canvas.parentNode) {
      this.canvas.parentNode.removeChild(this.canvas);
    }
    if (this.overlayCanvas.parentNode) {
      this.overlayCanvas.parentNode.removeChild(this.overlayCanvas);
    }
  }
}
