// wasm-renderer.js — WASM-backed renderer replacing Three.js Renderer3D
// Loads the AssemblyScript WASM module, manages scene state via WASM exports,
// and uses WebGLExecutor to process batched WebGL commands.

import { WebGLExecutor } from './webgl-executor.js';

/**
 * WasmRenderer — drop-in replacement for Renderer3D.
 *
 * Public surface kept compatible with main.js usage:
 *   - constructor(container)
 *   - setMode(mode)           '2d' | '3d'
 *   - setVisible(visible)
 *   - onWindowResize()
 *   - sync2DView(viewport)
 *   - render2DScene(scene, overlays)
 *   - renderPart(part)
 *   - clearPartGeometry()
 *   - clearGeometry()
 *   - fitToView()
 *   - screenToWorld(sx, sy)
 *   - dispose()
 *   - renderer.domElement        (the <canvas>)
 */
export class WasmRenderer {
  constructor(container) {
    this.container = container;
    this.mode = '2d';
    this._ready = false;

    // Create a <canvas> that fills the container
    this.canvas = document.createElement('canvas');
    this.canvas.style.width = '100%';
    this.canvas.style.height = '100%';
    this.canvas.style.display = 'block';
    container.appendChild(this.canvas);

    const width = container.clientWidth || 800;
    const height = container.clientHeight || 600;
    this.canvas.width = width;
    this.canvas.height = height;

    // WebGL executor
    this.executor = new WebGLExecutor(this.canvas);

    // 2D overlay canvas for text/sprites/dimension labels
    this.overlayCanvas = document.createElement('canvas');
    this.overlayCanvas.style.position = 'absolute';
    this.overlayCanvas.style.left = '0';
    this.overlayCanvas.style.top = '0';
    this.overlayCanvas.style.width = '100%';
    this.overlayCanvas.style.height = '100%';
    this.overlayCanvas.style.pointerEvents = 'none';
    this.overlayCanvas.width = width;
    this.overlayCanvas.height = height;
    container.appendChild(this.overlayCanvas);
    this.overlayCtx = this.overlayCanvas.getContext('2d');

    // Compatibility shim: renderer.domElement
    this.renderer = { domElement: this.canvas };

    // WASM module handle (set after load)
    this.wasm = null;
    this.wasmMemory = null;

    // View state for 2D
    this._orthoBounds = { left: -500, right: 500, bottom: -375, top: 375 };
    this._cameraPos = { x: 0, y: 0, z: 500 };

    // Part data stored for 3D render
    this._partNodes = [];

    // Window resize handler
    this._resizeHandler = () => this.onWindowResize();
    window.addEventListener('resize', this._resizeHandler);

    // Load WASM
    this._loadPromise = this._loadWasm();

    // Start animation loop
    this._animationId = null;
    this._animate();
  }

  async _loadWasm() {
    try {
      // Use the ESM bindings generated by AssemblyScript
      const mod = await import('../build/release.js');
      this.wasm = mod;
      const width = this.canvas.width;
      const height = this.canvas.height;
      this.wasm.init(width, height);
      this._ready = true;
    } catch (err) {
      console.error('WasmRenderer: failed to load WASM module', err);
    }
  }

  /* ---------- animation loop ---------- */
  _animate() {
    this._animationId = requestAnimationFrame(() => this._animate());
    if (!this._ready) return;
    this._renderFrame();
  }

  _renderFrame() {
    const wasm = this.wasm;
    if (!wasm) return;

    wasm.render();
    const ptr = wasm.getCommandBufferPtr();
    const len = wasm.getCommandBufferLen();
    if (len <= 0) return;

    // Read command buffer from WASM linear memory
    const memory = wasm.memory || (wasm.__getMemory && wasm.__getMemory());
    if (!memory) return;
    const buf = new Float32Array(memory.buffer, ptr, len);
    this.executor.execute(buf, len);
  }

  /* ---------- mode switching ---------- */
  setMode(mode) {
    this.mode = mode;
    if (!this._ready) return;

    if (mode === '2d') {
      this.wasm.setCameraMode(0);
      // Reset ortho
      const w = this.canvas.width;
      const h = this.canvas.height;
      const aspect = w / h;
      const viewSize = 500;
      this._orthoBounds = {
        left: -viewSize * aspect,
        right: viewSize * aspect,
        bottom: -viewSize,
        top: viewSize,
      };
      this.wasm.setOrthoBounds(
        this._orthoBounds.left, this._orthoBounds.right,
        this._orthoBounds.bottom, this._orthoBounds.top
      );
      this.wasm.setCameraPosition(0, 0, 500);
      this.wasm.setCameraTarget(0, 0, 0);
      this.wasm.setGridVisible(1);
      this.wasm.setAxesVisible(1);
    } else {
      this.wasm.setCameraMode(1);
      this.wasm.setCameraPosition(300, 300, 300);
      this.wasm.setCameraTarget(0, 0, 0);
      this.wasm.setGridVisible(1);
      this.wasm.setAxesVisible(1);
    }
  }

  setVisible(visible) {
    this.canvas.style.display = visible ? 'block' : 'none';
    this.overlayCanvas.style.display = visible ? 'block' : 'none';
  }

  onWindowResize() {
    const w = this.container.clientWidth;
    const h = this.container.clientHeight;
    if (w <= 0 || h <= 0) return;

    this.canvas.width = w;
    this.canvas.height = h;
    this.overlayCanvas.width = w;
    this.overlayCanvas.height = h;
    this.executor.resize(w, h);

    if (this._ready) {
      this.wasm.resize(w, h);
    }
  }

  /* ---------- 2D Sketch Rendering ---------- */

  /**
   * Sync orthographic camera to legacy viewport pan/zoom.
   */
  sync2DView(viewport) {
    if (!viewport || !this._ready || this.mode !== '2d') return;

    const zoom = Math.max(0.0001, viewport.zoom || 1);
    const w = Math.max(1, viewport.width || this.canvas.width);
    const h = Math.max(1, viewport.height || this.canvas.height);

    const halfW = w / (2 * zoom);
    const halfH = h / (2 * zoom);

    const cx = -viewport.panX / zoom;
    const cy = viewport.panY / zoom;

    this._orthoBounds = { left: cx - halfW, right: cx + halfW, bottom: cy - halfH, top: cy + halfH };
    this._cameraPos = { x: cx, y: cy, z: 500 };

    this.wasm.setOrthoBounds(cx - halfW, cx + halfW, cy - halfH, cy + halfH);
    this.wasm.setCameraPosition(cx, cy, 500);
    this.wasm.setCameraTarget(cx, cy, 0);
  }

  /**
   * Render 2D sketch entities.
   * The WASM module handles the grid/axes. 2D overlay (entities, dimensions,
   * constraints, hover, snap, etc.) is drawn on the overlay canvas via Canvas2D
   * since those elements are highly dynamic text/icons.
   */
  render2DScene(scene, overlays = {}) {
    if (!scene) return;

    const ctx = this.overlayCtx;
    const w = this.overlayCanvas.width;
    const h = this.overlayCanvas.height;
    ctx.clearRect(0, 0, w, h);

    // Coordinate mapping helpers
    const bounds = this._orthoBounds;
    const worldToScreenX = (wx) => ((wx - bounds.left) / (bounds.right - bounds.left)) * w;
    const worldToScreenY = (wy) => ((bounds.top - wy) / (bounds.top - bounds.bottom)) * h;
    const wpp = (bounds.right - bounds.left) / w; // world per pixel

    const isLayerVisible = overlays.isLayerVisible || (() => true);
    const getLayerColor = overlays.getLayerColor || (() => '#9CDCFE');
    const hoverEntity = overlays.hoverEntity || null;
    const previewEntities = overlays.previewEntities || [];
    const snapPoint = overlays.snapPoint || null;
    const cursorWorld = overlays.cursorWorld || null;
    const allDimensionsVisible = overlays.allDimensionsVisible !== false;
    const constraintIconsVisible = overlays.constraintIconsVisible !== false;

    const colorForEntity = (entity) => {
      if (entity.selected) return '#00bfff';
      if (entity.construction) return '#90EE90';
      return entity.color || getLayerColor(entity.layer);
    };

    // --- Segments ---
    if (scene.segments) {
      scene.segments.forEach((seg) => {
        if (!seg.visible || !isLayerVisible(seg.layer) || !seg.p1 || !seg.p2) return;
        const color = colorForEntity(seg);
        ctx.strokeStyle = color;
        ctx.lineWidth = seg.selected ? 2 : 1;

        if (seg.construction) {
          ctx.setLineDash([6, 4]);
        } else {
          ctx.setLineDash([]);
        }

        let x1 = seg.p1.x, y1 = seg.p1.y, x2 = seg.p2.x, y2 = seg.p2.y;

        if (seg.construction) {
          const dx = x2 - x1, dy = y2 - y1;
          const len = Math.hypot(dx, dy) || 1e-9;
          const ux = dx / len, uy = dy / len;
          const ext = Math.max(w, h) * wpp * 2;
          const ct = seg.constructionType || 'finite';
          if (ct === 'infinite-both') {
            x1 -= ux * ext; y1 -= uy * ext;
            x2 += ux * ext; y2 += uy * ext;
          } else if (ct === 'infinite-start') {
            x1 -= ux * ext; y1 -= uy * ext;
          } else if (ct === 'infinite-end') {
            x2 += ux * ext; y2 += uy * ext;
          }
        }

        ctx.beginPath();
        ctx.moveTo(worldToScreenX(x1), worldToScreenY(y1));
        ctx.lineTo(worldToScreenX(x2), worldToScreenY(y2));
        ctx.stroke();
        ctx.setLineDash([]);
      });
    }

    // --- Circles ---
    if (scene.circles) {
      scene.circles.forEach((circle) => {
        if (!circle.visible || !isLayerVisible(circle.layer)) return;
        const color = colorForEntity(circle);
        ctx.strokeStyle = color;
        ctx.lineWidth = circle.selected ? 2 : 1;
        ctx.setLineDash(circle.construction ? [6, 4] : []);
        const sx = worldToScreenX(circle.center.x);
        const sy = worldToScreenY(circle.center.y);
        const sr = circle.radius / wpp;
        ctx.beginPath();
        ctx.arc(sx, sy, sr, 0, Math.PI * 2);
        ctx.stroke();
        ctx.setLineDash([]);
      });
    }

    // --- Arcs ---
    if (scene.arcs) {
      scene.arcs.forEach((arc) => {
        if (!arc.visible || !isLayerVisible(arc.layer)) return;
        const color = colorForEntity(arc);
        ctx.strokeStyle = color;
        ctx.lineWidth = arc.selected ? 2 : 1;
        ctx.setLineDash(arc.construction ? [6, 4] : []);
        const sx = worldToScreenX(arc.center.x);
        const sy = worldToScreenY(arc.center.y);
        const sr = arc.radius / wpp;
        ctx.beginPath();
        // Canvas arcs go clockwise; flip for Y-up world
        ctx.arc(sx, sy, sr, -arc.startAngle, -arc.endAngle, true);
        ctx.stroke();
        ctx.setLineDash([]);
      });
    }

    // --- Texts ---
    if (scene.texts) {
      scene.texts.forEach((text) => {
        if (!text.visible || !isLayerVisible(text.layer)) return;
        const color = colorForEntity(text);
        ctx.fillStyle = color;
        ctx.font = '14px Consolas, monospace';
        ctx.textBaseline = 'middle';
        const sx = worldToScreenX(text.x);
        const sy = worldToScreenY(text.y);
        ctx.save();
        ctx.translate(sx, sy);
        if (text.rotation) ctx.rotate(-text.rotation * Math.PI / 180);
        ctx.fillText(text.text, 0, 0);
        ctx.restore();
      });
    }

    // --- Dimensions ---
    if (allDimensionsVisible && scene.dimensions) {
      scene.dimensions.forEach((dim) => {
        if (!dim.visible || !isLayerVisible(dim.layer)) return;
        const isHover = hoverEntity && hoverEntity.id === dim.id;
        const dimColor = dim.selected ? '#00bfff' : (isHover ? '#7fd8ff' : (!dim.isConstraint ? '#ffb432' : (dim.color || getLayerColor(dim.layer))));
        ctx.strokeStyle = dimColor;
        ctx.fillStyle = dimColor;
        ctx.lineWidth = 1;
        ctx.setLineDash([]);

        if (dim.dimType === 'angle') {
          const r = Math.abs(dim.offset) / wpp;
          const startA = dim._angleStart != null ? dim._angleStart : 0;
          const sweepA = dim._angleSweep != null ? dim._angleSweep : 0;
          const cx = worldToScreenX(dim.x1);
          const cy = worldToScreenY(dim.y1);
          ctx.beginPath();
          ctx.arc(cx, cy, r, -startA, -(startA + sweepA), true);
          ctx.stroke();
          const midA = startA + sweepA / 2;
          const lx = worldToScreenX(dim.x1 + (Math.abs(dim.offset) + 14 * wpp) * Math.cos(midA));
          const ly = worldToScreenY(dim.y1 + (Math.abs(dim.offset) + 14 * wpp) * Math.sin(midA));
          ctx.font = '12px Consolas, monospace';
          ctx.textBaseline = 'middle';
          ctx.fillText(dim.displayLabel || '', lx, ly);
          return;
        }

        const dx = dim.x2 - dim.x1;
        const dy = dim.y2 - dim.y1;
        const len = Math.hypot(dx, dy) || 1e-9;
        const nx = -dy / len, ny = dx / len;
        let d1, d2;

        if (dim.dimType === 'dx') {
          const dimY = dim.y1 + dim.offset;
          d1 = { x: dim.x1, y: dimY };
          d2 = { x: dim.x2, y: dimY };
        } else if (dim.dimType === 'dy') {
          const dimX = dim.x1 + dim.offset;
          d1 = { x: dimX, y: dim.y1 };
          d2 = { x: dimX, y: dim.y2 };
        } else {
          d1 = { x: dim.x1 + nx * dim.offset, y: dim.y1 + ny * dim.offset };
          d2 = { x: dim.x2 + nx * dim.offset, y: dim.y2 + ny * dim.offset };
        }

        // Extension lines
        ctx.beginPath();
        ctx.moveTo(worldToScreenX(dim.x1), worldToScreenY(dim.y1));
        ctx.lineTo(worldToScreenX(d1.x), worldToScreenY(d1.y));
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(worldToScreenX(dim.x2), worldToScreenY(dim.y2));
        ctx.lineTo(worldToScreenX(d2.x), worldToScreenY(d2.y));
        ctx.stroke();

        // Dimension line
        ctx.beginPath();
        ctx.moveTo(worldToScreenX(d1.x), worldToScreenY(d1.y));
        ctx.lineTo(worldToScreenX(d2.x), worldToScreenY(d2.y));
        ctx.stroke();

        // Label
        const mx = (d1.x + d2.x) / 2;
        const my = (d1.y + d2.y) / 2 + 12 * wpp;
        ctx.font = '12px Consolas, monospace';
        ctx.textBaseline = 'middle';
        ctx.textAlign = 'center';
        ctx.fillText(dim.displayLabel || '', worldToScreenX(mx), worldToScreenY(my));
        ctx.textAlign = 'left';
      });
    }

    // --- Points ---
    if (scene.points) {
      scene.points.forEach((point) => {
        const refs = scene.shapesUsingPoint ? scene.shapesUsingPoint(point).length : 1;
        const isHover = hoverEntity && hoverEntity.id === point.id;
        if (refs <= 1 && !point.selected && !point.fixed && !isHover) return;
        const color = point.selected ? '#00bfff' : (isHover ? '#7fd8ff' : (point.fixed ? '#ff6644' : '#ffff66'));
        const size = point.selected ? 7 : (isHover ? 6 : (point.fixed ? 5 : 4));
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.arc(worldToScreenX(point.x), worldToScreenY(point.y), size / 2, 0, Math.PI * 2);
        ctx.fill();
      });
    }

    // --- Constraint icons ---
    if (constraintIconsVisible && scene.constraints) {
      const iconMap = {
        coincident: '⊙', distance: '↔', fixed: '⊕',
        horizontal: 'H', vertical: 'V', parallel: '∥', perpendicular: '⊥',
        angle: '∠', equal_length: '=', length: 'L', radius: 'R', tangent: 'T',
        on_line: '—·', on_circle: '○·', midpoint: 'M',
      };
      scene.constraints.forEach((constraint) => {
        if (constraint.type === 'dimension') return;
        if (typeof constraint.involvedPoints !== 'function') return;
        const pts = constraint.involvedPoints();
        if (!pts || pts.length === 0) return;
        let cx = 0, cy = 0;
        for (const p of pts) { cx += p.x; cy += p.y; }
        cx /= pts.length; cy /= pts.length;
        const icon = iconMap[constraint.type] || '?';
        const ok = (typeof constraint.error === 'function') ? constraint.error() < 1e-4 : false;
        ctx.fillStyle = ok ? '#00e676' : '#ff643c';
        ctx.font = '13px Consolas, monospace';
        ctx.fillText(icon, worldToScreenX(cx + 12 * wpp), worldToScreenY(cy + 10 * wpp));
      });
    }

    // --- Hover highlight ---
    if (hoverEntity && hoverEntity.visible !== false) {
      const hc = '#7fd8ff';
      ctx.strokeStyle = hc;
      ctx.lineWidth = 2;
      ctx.setLineDash([]);
      if (hoverEntity.type === 'segment' && hoverEntity.p1 && hoverEntity.p2) {
        ctx.beginPath();
        ctx.moveTo(worldToScreenX(hoverEntity.p1.x), worldToScreenY(hoverEntity.p1.y));
        ctx.lineTo(worldToScreenX(hoverEntity.p2.x), worldToScreenY(hoverEntity.p2.y));
        ctx.stroke();
      } else if (hoverEntity.type === 'circle' && hoverEntity.center) {
        ctx.beginPath();
        ctx.arc(worldToScreenX(hoverEntity.center.x), worldToScreenY(hoverEntity.center.y), hoverEntity.radius / wpp, 0, Math.PI * 2);
        ctx.stroke();
      } else if (hoverEntity.type === 'arc' && hoverEntity.center) {
        ctx.beginPath();
        ctx.arc(worldToScreenX(hoverEntity.center.x), worldToScreenY(hoverEntity.center.y), hoverEntity.radius / wpp, -hoverEntity.startAngle, -hoverEntity.endAngle, true);
        ctx.stroke();
      }
    }

    // --- Preview entities ---
    if (previewEntities && previewEntities.length > 0) {
      ctx.strokeStyle = '#00bfff';
      ctx.lineWidth = 1;
      ctx.setLineDash([]);
      previewEntities.forEach((entity) => {
        if (!entity) return;
        if (entity.type === 'segment' && entity.p1 && entity.p2) {
          ctx.beginPath();
          ctx.moveTo(worldToScreenX(entity.p1.x), worldToScreenY(entity.p1.y));
          ctx.lineTo(worldToScreenX(entity.p2.x), worldToScreenY(entity.p2.y));
          ctx.stroke();
        } else if (entity.type === 'circle' && entity.center) {
          ctx.beginPath();
          ctx.arc(worldToScreenX(entity.center.x), worldToScreenY(entity.center.y), entity.radius / wpp, 0, Math.PI * 2);
          ctx.stroke();
        } else if (entity.type === 'arc' && entity.center) {
          ctx.beginPath();
          ctx.arc(worldToScreenX(entity.center.x), worldToScreenY(entity.center.y), entity.radius / wpp, -entity.startAngle, -entity.endAngle, true);
          ctx.stroke();
        }
      });
    }

    // --- Snap indicator ---
    if (snapPoint) {
      ctx.fillStyle = '#00ff99';
      ctx.beginPath();
      ctx.arc(worldToScreenX(snapPoint.x), worldToScreenY(snapPoint.y), 5, 0, Math.PI * 2);
      ctx.fill();
    }

    // --- Crosshair ---
    if (cursorWorld && this.mode === '2d') {
      ctx.strokeStyle = '#2a2a2a';
      ctx.lineWidth = 1;
      ctx.setLineDash([]);
      const sx = worldToScreenX(cursorWorld.x);
      const sy = worldToScreenY(cursorWorld.y);
      ctx.beginPath();
      ctx.moveTo(0, sy); ctx.lineTo(w, sy);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(sx, 0); ctx.lineTo(sx, h);
      ctx.stroke();
    }
  }

  /* ---------- 3D Part Rendering ---------- */

  renderPart(part) {
    this.clearPartGeometry();
    if (!part || !this._ready) return;

    const geo = part.getFinalGeometry();
    if (!geo) return;

    if (geo.type === 'solid' && geo.geometry) {
      // Add a box-like representation using bounding box
      const bb = geo.boundingBox;
      if (bb) {
        const sx = bb.max.x - bb.min.x;
        const sy = bb.max.y - bb.min.y;
        const sz = bb.max.z - bb.min.z;
        const px = (bb.max.x + bb.min.x) / 2;
        const py = (bb.max.y + bb.min.y) / 2;
        const pz = (bb.max.z + bb.min.z) / 2;
        const id = this.wasm.addBox(sx, sy, sz, px, py, pz, 0.3, 0.69, 0.31, 1.0);
        this._partNodes.push(id);
      }
    }
  }

  clearPartGeometry() {
    if (!this._ready) return;
    for (const id of this._partNodes) {
      this.wasm.removeNode(id);
    }
    this._partNodes = [];
  }

  clearGeometry() {
    this.clearPartGeometry();
    if (this._ready) {
      this.wasm.clearScene();
    }
  }

  fitToView() {
    // A simple default: position camera back to see the part
    if (!this._ready) return;
    if (this.mode === '3d') {
      this.wasm.setCameraPosition(300, 300, 300);
      this.wasm.setCameraTarget(0, 0, 0);
    }
  }

  /**
   * Convert screen coordinates to world coordinates on the XY plane.
   */
  screenToWorld(screenX, screenY) {
    const rect = this.canvas.getBoundingClientRect();
    const ndcX = ((screenX - rect.left) / rect.width) * 2 - 1;
    const ndcY = -((screenY - rect.top) / rect.height) * 2 + 1;

    const bounds = this._orthoBounds;
    const wx = bounds.left + (ndcX + 1) * 0.5 * (bounds.right - bounds.left);
    const wy = bounds.bottom + (ndcY + 1) * 0.5 * (bounds.top - bounds.bottom);
    return { x: wx, y: wy };
  }

  dispose() {
    if (this._animationId) {
      cancelAnimationFrame(this._animationId);
    }
    this.clearGeometry();
    this.executor.dispose();
    if (this._resizeHandler) {
      window.removeEventListener('resize', this._resizeHandler);
    }
    if (this.canvas.parentNode) {
      this.canvas.parentNode.removeChild(this.canvas);
    }
    if (this.overlayCanvas.parentNode) {
      this.overlayCanvas.parentNode.removeChild(this.overlayCanvas);
    }
  }
}
