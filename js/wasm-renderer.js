// wasm-renderer.js — WASM-backed renderer replacing Three.js Renderer3D
// Loads the AssemblyScript WASM module, manages scene state via WASM exports,
// and uses WebGLExecutor to process batched WebGL commands.

import { WebGLExecutor } from './webgl-executor.js';

/**
 * WasmRenderer — drop-in replacement for Renderer3D.
 *
 * Public surface kept compatible with main.js usage:
 *   - constructor(container)
 *   - setMode(mode)           '2d' | '3d'
 *   - setVisible(visible)
 *   - onWindowResize()
 *   - sync2DView(viewport)
 *   - render2DScene(scene, overlays)
 *   - renderPart(part)
 *   - clearPartGeometry()
 *   - clearGeometry()
 *   - fitToView()
 *   - screenToWorld(sx, sy)
 *   - dispose()
 *   - renderer.domElement        (the <canvas>)
 */
export class WasmRenderer {
  constructor(container) {
    this.container = container;
    this.mode = '2d';
    this._ready = false;

    // Create a <canvas> that fills the container
    this.canvas = document.createElement('canvas');
    this.canvas.style.width = '100%';
    this.canvas.style.height = '100%';
    this.canvas.style.display = 'block';
    container.appendChild(this.canvas);

    const width = container.clientWidth || 800;
    const height = container.clientHeight || 600;
    this.canvas.width = width;
    this.canvas.height = height;

    // WebGL executor
    this.executor = new WebGLExecutor(this.canvas);

    // 2D overlay canvas for text/sprites/dimension labels
    this.overlayCanvas = document.createElement('canvas');
    this.overlayCanvas.style.position = 'absolute';
    this.overlayCanvas.style.left = '0';
    this.overlayCanvas.style.top = '0';
    this.overlayCanvas.style.width = '100%';
    this.overlayCanvas.style.height = '100%';
    this.overlayCanvas.style.pointerEvents = 'none';
    this.overlayCanvas.width = width;
    this.overlayCanvas.height = height;
    container.appendChild(this.overlayCanvas);
    this.overlayCtx = this.overlayCanvas.getContext('2d');

    // Compatibility shim: renderer.domElement
    this.renderer = { domElement: this.canvas };

    // WASM module handle (set after load)
    this.wasm = null;
    this.wasmMemory = null;

    // View state for 2D
    this._orthoBounds = { left: -500, right: 500, bottom: -375, top: 375 };
    this._cameraPos = { x: 0, y: 0, z: 500 };

    // Part data stored for 3D render
    this._partNodes = [];

    // Window resize handler
    this._resizeHandler = () => this.onWindowResize();
    window.addEventListener('resize', this._resizeHandler);

    // Load WASM
    this._loadPromise = this._loadWasm();

    // Start animation loop
    this._animationId = null;
    this._animate();
  }

  async _loadWasm() {
    try {
      // Use the ESM bindings generated by AssemblyScript
      const mod = await import('../build/release.js');
      this.wasm = mod;
      const width = this.canvas.width;
      const height = this.canvas.height;
      this.wasm.init(width, height);
      this._ready = true;
    } catch (err) {
      console.error('WasmRenderer: failed to load WASM module', err);
    }
  }

  /* ---------- animation loop ---------- */
  _animate() {
    this._animationId = requestAnimationFrame(() => this._animate());
    if (!this._ready) return;
    this._renderFrame();
  }

  _renderFrame() {
    const wasm = this.wasm;
    if (!wasm) return;

    wasm.render();
    const ptr = wasm.getCommandBufferPtr();
    const len = wasm.getCommandBufferLen();
    if (len <= 0) return;

    // Read command buffer from WASM linear memory
    const memory = wasm.memory || (wasm.__getMemory && wasm.__getMemory());
    if (!memory) return;
    const buf = new Float32Array(memory.buffer, ptr, len);
    this.executor.execute(buf, len);
  }

  /* ---------- mode switching ---------- */
  setMode(mode) {
    this.mode = mode;
    if (!this._ready) return;

    if (mode === '2d') {
      this.wasm.setCameraMode(0);
      // Reset ortho
      const w = this.canvas.width;
      const h = this.canvas.height;
      const aspect = w / h;
      const viewSize = 500;
      this._orthoBounds = {
        left: -viewSize * aspect,
        right: viewSize * aspect,
        bottom: -viewSize,
        top: viewSize,
      };
      this.wasm.setOrthoBounds(
        this._orthoBounds.left, this._orthoBounds.right,
        this._orthoBounds.bottom, this._orthoBounds.top
      );
      this.wasm.setCameraPosition(0, 0, 500);
      this.wasm.setCameraTarget(0, 0, 0);
      this.wasm.setGridVisible(1);
      this.wasm.setAxesVisible(1);
    } else {
      this.wasm.setCameraMode(1);
      this.wasm.setCameraPosition(300, 300, 300);
      this.wasm.setCameraTarget(0, 0, 0);
      this.wasm.setGridVisible(1);
      this.wasm.setAxesVisible(1);
    }
  }

  setVisible(visible) {
    this.canvas.style.display = visible ? 'block' : 'none';
    this.overlayCanvas.style.display = visible ? 'block' : 'none';
  }

  onWindowResize() {
    const w = this.container.clientWidth;
    const h = this.container.clientHeight;
    if (w <= 0 || h <= 0) return;

    this.canvas.width = w;
    this.canvas.height = h;
    this.overlayCanvas.width = w;
    this.overlayCanvas.height = h;
    this.executor.resize(w, h);

    if (this._ready) {
      this.wasm.resize(w, h);
    }
  }

  /* ---------- 2D Sketch Rendering ---------- */

  /**
   * Sync orthographic camera to legacy viewport pan/zoom.
   */
  sync2DView(viewport) {
    if (!viewport || !this._ready || this.mode !== '2d') return;

    const zoom = Math.max(0.0001, viewport.zoom || 1);
    const w = Math.max(1, viewport.width || this.canvas.width);
    const h = Math.max(1, viewport.height || this.canvas.height);

    const halfW = w / (2 * zoom);
    const halfH = h / (2 * zoom);

    const cx = -viewport.panX / zoom;
    const cy = viewport.panY / zoom;

    this._orthoBounds = { left: cx - halfW, right: cx + halfW, bottom: cy - halfH, top: cy + halfH };
    this._cameraPos = { x: cx, y: cy, z: 500 };

    this.wasm.setOrthoBounds(cx - halfW, cx + halfW, cy - halfH, cy + halfH);
    this.wasm.setCameraPosition(cx, cy, 500);
    this.wasm.setCameraTarget(cx, cy, 0);
  }

  /**
   * Render 2D sketch entities.
   * Pushes entity data to WASM for GPU-accelerated rendering.
   * Text/dimension labels and constraint icons remain on the overlay canvas
   * since WebGL does not natively support text.
   */
  render2DScene(scene, overlays = {}) {
    if (!scene || !this._ready) return;

    const wasm = this.wasm;
    wasm.clearEntities();

    const isLayerVisible = overlays.isLayerVisible || (() => true);
    const getLayerColor = overlays.getLayerColor || (() => '#9CDCFE');
    const hoverEntity = overlays.hoverEntity || null;
    const previewEntities = overlays.previewEntities || [];
    const snapPoint = overlays.snapPoint || null;
    const cursorWorld = overlays.cursorWorld || null;
    const allDimensionsVisible = overlays.allDimensionsVisible !== false;
    const constraintIconsVisible = overlays.constraintIconsVisible !== false;

    // Entity flag constants
    const F_VISIBLE = 1;
    const F_SELECTED = 2;
    const F_CONSTRUCTION = 4;
    const F_HOVER = 8;
    const F_FIXED = 16;
    const F_PREVIEW = 32;

    const parseColor = (colorStr) => {
      if (!colorStr || typeof colorStr !== 'string') return [0.612, 0.863, 0.996, 1.0];
      if (colorStr.startsWith('#')) {
        const hex = colorStr.slice(1);
        if (hex.length === 6) {
          return [
            parseInt(hex.slice(0, 2), 16) / 255,
            parseInt(hex.slice(2, 4), 16) / 255,
            parseInt(hex.slice(4, 6), 16) / 255,
            1.0
          ];
        }
      }
      return [0.612, 0.863, 0.996, 1.0];
    };

    const entityColor = (entity) => {
      if (entity.selected) return [0, 0.749, 1, 1];
      if (entity.construction) return [0.565, 0.933, 0.565, 1];
      const c = entity.color || getLayerColor(entity.layer);
      return parseColor(c);
    };

    // --- Push segments to WASM ---
    if (scene.segments) {
      scene.segments.forEach((seg) => {
        if (!seg.visible || !isLayerVisible(seg.layer) || !seg.p1 || !seg.p2) return;
        let flags = F_VISIBLE;
        if (seg.selected) flags |= F_SELECTED;
        if (seg.construction) flags |= F_CONSTRUCTION;
        if (hoverEntity && hoverEntity.id === seg.id) flags |= F_HOVER;
        const [r, g, b, a] = entityColor(seg);
        wasm.addEntitySegment(seg.p1.x, seg.p1.y, seg.p2.x, seg.p2.y, flags, r, g, b, a);
      });
    }

    // --- Push circles to WASM ---
    if (scene.circles) {
      scene.circles.forEach((circle) => {
        if (!circle.visible || !isLayerVisible(circle.layer)) return;
        let flags = F_VISIBLE;
        if (circle.selected) flags |= F_SELECTED;
        if (circle.construction) flags |= F_CONSTRUCTION;
        if (hoverEntity && hoverEntity.id === circle.id) flags |= F_HOVER;
        const [r, g, b, a] = entityColor(circle);
        wasm.addEntityCircle(circle.center.x, circle.center.y, circle.radius, flags, r, g, b, a);
      });
    }

    // --- Push arcs to WASM ---
    if (scene.arcs) {
      scene.arcs.forEach((arc) => {
        if (!arc.visible || !isLayerVisible(arc.layer)) return;
        let flags = F_VISIBLE;
        if (arc.selected) flags |= F_SELECTED;
        if (arc.construction) flags |= F_CONSTRUCTION;
        if (hoverEntity && hoverEntity.id === arc.id) flags |= F_HOVER;
        const [r, g, b, a] = entityColor(arc);
        wasm.addEntityArc(arc.center.x, arc.center.y, arc.radius, arc.startAngle, arc.endAngle, flags, r, g, b, a);
      });
    }

    // --- Push points to WASM ---
    if (scene.points) {
      scene.points.forEach((point) => {
        const refs = scene.shapesUsingPoint ? scene.shapesUsingPoint(point).length : 1;
        const isHover = hoverEntity && hoverEntity.id === point.id;
        if (refs <= 1 && !point.selected && !point.fixed && !isHover) return;
        let flags = F_VISIBLE;
        if (point.selected) flags |= F_SELECTED;
        if (isHover) flags |= F_HOVER;
        if (point.fixed) flags |= F_FIXED;
        const size = point.selected ? 7 : (isHover ? 6 : (point.fixed ? 5 : 4));
        const [r, g, b, a] = point.selected ? [0, 0.749, 1, 1]
          : (isHover ? [0.498, 0.847, 1, 1]
            : (point.fixed ? [1, 0.4, 0.267, 1]
              : [1, 1, 0.4, 1]));
        wasm.addEntityPoint(point.x, point.y, size, flags, r, g, b, a);
      });
    }

    // --- Push preview entities to WASM ---
    if (previewEntities && previewEntities.length > 0) {
      previewEntities.forEach((entity) => {
        if (!entity) return;
        const flags = F_VISIBLE | F_PREVIEW;
        if (entity.type === 'segment' && entity.p1 && entity.p2) {
          wasm.addEntitySegment(entity.p1.x, entity.p1.y, entity.p2.x, entity.p2.y, flags, 0, 0.749, 1, 1);
        } else if (entity.type === 'circle' && entity.center) {
          wasm.addEntityCircle(entity.center.x, entity.center.y, entity.radius, flags, 0, 0.749, 1, 1);
        } else if (entity.type === 'arc' && entity.center) {
          wasm.addEntityArc(entity.center.x, entity.center.y, entity.radius, entity.startAngle, entity.endAngle, flags, 0, 0.749, 1, 1);
        }
      });
    }

    // --- Snap point ---
    if (snapPoint) {
      wasm.setSnapPosition(snapPoint.x, snapPoint.y, 1);
    } else {
      wasm.setSnapPosition(0, 0, 0);
    }

    // --- Cursor crosshair ---
    if (cursorWorld && this.mode === '2d') {
      wasm.setCursorPosition(cursorWorld.x, cursorWorld.y, 1);
    } else {
      wasm.setCursorPosition(0, 0, 0);
    }

    // --- Overlay canvas for text-based elements (dimensions, constraint icons) ---
    const ctx = this.overlayCtx;
    const w = this.overlayCanvas.width;
    const h = this.overlayCanvas.height;
    ctx.clearRect(0, 0, w, h);

    const bounds = this._orthoBounds;
    const worldToScreenX = (wx) => ((wx - bounds.left) / (bounds.right - bounds.left)) * w;
    const worldToScreenY = (wy) => ((bounds.top - wy) / (bounds.top - bounds.bottom)) * h;
    const wpp = (bounds.right - bounds.left) / w;

    // --- Dimensions (text overlay) ---
    if (allDimensionsVisible && scene.dimensions) {
      scene.dimensions.forEach((dim) => {
        if (!dim.visible || !isLayerVisible(dim.layer)) return;
        const isHover = hoverEntity && hoverEntity.id === dim.id;
        const dimColor = dim.selected ? '#00bfff' : (isHover ? '#7fd8ff' : (!dim.isConstraint ? '#ffb432' : (dim.color || getLayerColor(dim.layer))));
        ctx.strokeStyle = dimColor;
        ctx.fillStyle = dimColor;
        ctx.lineWidth = 1;
        ctx.setLineDash([]);

        if (dim.dimType === 'angle') {
          const r = Math.abs(dim.offset) / wpp;
          const startA = dim._angleStart != null ? dim._angleStart : 0;
          const sweepA = dim._angleSweep != null ? dim._angleSweep : 0;
          const cx = worldToScreenX(dim.x1);
          const cy = worldToScreenY(dim.y1);
          ctx.beginPath();
          ctx.arc(cx, cy, r, -startA, -(startA + sweepA), true);
          ctx.stroke();
          const midA = startA + sweepA / 2;
          const lx = worldToScreenX(dim.x1 + (Math.abs(dim.offset) + 14 * wpp) * Math.cos(midA));
          const ly = worldToScreenY(dim.y1 + (Math.abs(dim.offset) + 14 * wpp) * Math.sin(midA));
          ctx.font = '12px Consolas, monospace';
          ctx.textBaseline = 'middle';
          ctx.fillText(dim.displayLabel || '', lx, ly);
          return;
        }

        const dx = dim.x2 - dim.x1;
        const dy = dim.y2 - dim.y1;
        const len = Math.hypot(dx, dy) || 1e-9;
        const nx = -dy / len, ny = dx / len;
        let d1, d2;

        if (dim.dimType === 'dx') {
          const dimY = dim.y1 + dim.offset;
          d1 = { x: dim.x1, y: dimY };
          d2 = { x: dim.x2, y: dimY };
        } else if (dim.dimType === 'dy') {
          const dimX = dim.x1 + dim.offset;
          d1 = { x: dimX, y: dim.y1 };
          d2 = { x: dimX, y: dim.y2 };
        } else {
          d1 = { x: dim.x1 + nx * dim.offset, y: dim.y1 + ny * dim.offset };
          d2 = { x: dim.x2 + nx * dim.offset, y: dim.y2 + ny * dim.offset };
        }

        ctx.beginPath();
        ctx.moveTo(worldToScreenX(dim.x1), worldToScreenY(dim.y1));
        ctx.lineTo(worldToScreenX(d1.x), worldToScreenY(d1.y));
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(worldToScreenX(dim.x2), worldToScreenY(dim.y2));
        ctx.lineTo(worldToScreenX(d2.x), worldToScreenY(d2.y));
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(worldToScreenX(d1.x), worldToScreenY(d1.y));
        ctx.lineTo(worldToScreenX(d2.x), worldToScreenY(d2.y));
        ctx.stroke();

        const mx = (d1.x + d2.x) / 2;
        const my = (d1.y + d2.y) / 2 + 12 * wpp;
        ctx.font = '12px Consolas, monospace';
        ctx.textBaseline = 'middle';
        ctx.textAlign = 'center';
        ctx.fillText(dim.displayLabel || '', worldToScreenX(mx), worldToScreenY(my));
        ctx.textAlign = 'left';
      });
    }

    // --- Texts ---
    if (scene.texts) {
      scene.texts.forEach((text) => {
        if (!text.visible || !isLayerVisible(text.layer)) return;
        const color = text.selected ? '#00bfff' : (text.color || getLayerColor(text.layer));
        ctx.fillStyle = color;
        ctx.font = '14px Consolas, monospace';
        ctx.textBaseline = 'middle';
        const sx = worldToScreenX(text.x);
        const sy = worldToScreenY(text.y);
        ctx.save();
        ctx.translate(sx, sy);
        if (text.rotation) ctx.rotate(-text.rotation * Math.PI / 180);
        ctx.fillText(text.text, 0, 0);
        ctx.restore();
      });
    }

    // --- Constraint icons ---
    if (constraintIconsVisible && scene.constraints) {
      const iconMap = {
        coincident: '⊙', distance: '↔', fixed: '⊕',
        horizontal: 'H', vertical: 'V', parallel: '∥', perpendicular: '⊥',
        angle: '∠', equal_length: '=', length: 'L', radius: 'R', tangent: 'T',
        on_line: '—·', on_circle: '○·', midpoint: 'M',
      };
      scene.constraints.forEach((constraint) => {
        if (constraint.type === 'dimension') return;
        if (typeof constraint.involvedPoints !== 'function') return;
        const pts = constraint.involvedPoints();
        if (!pts || pts.length === 0) return;
        let cx = 0, cy = 0;
        for (const p of pts) { cx += p.x; cy += p.y; }
        cx /= pts.length; cy /= pts.length;
        const icon = iconMap[constraint.type] || '?';
        const ok = (typeof constraint.error === 'function') ? constraint.error() < 1e-4 : false;
        ctx.fillStyle = ok ? '#00e676' : '#ff643c';
        ctx.font = '13px Consolas, monospace';
        ctx.fillText(icon, worldToScreenX(cx + 12 * wpp), worldToScreenY(cy + 10 * wpp));
      });
    }
  }

  /* ---------- 3D Part Rendering ---------- */

  renderPart(part) {
    this.clearPartGeometry();
    if (!part || !this._ready) return;

    const geo = part.getFinalGeometry();
    if (!geo) return;

    if (geo.type === 'solid' && geo.geometry) {
      // Add a box-like representation using bounding box
      const bb = geo.boundingBox;
      if (bb) {
        const sx = bb.max.x - bb.min.x;
        const sy = bb.max.y - bb.min.y;
        const sz = bb.max.z - bb.min.z;
        const px = (bb.max.x + bb.min.x) / 2;
        const py = (bb.max.y + bb.min.y) / 2;
        const pz = (bb.max.z + bb.min.z) / 2;
        const id = this.wasm.addBox(sx, sy, sz, px, py, pz, 0.3, 0.69, 0.31, 1.0);
        this._partNodes.push(id);
      }
    }
  }

  clearPartGeometry() {
    if (!this._ready) return;
    for (const id of this._partNodes) {
      this.wasm.removeNode(id);
    }
    this._partNodes = [];
  }

  clearGeometry() {
    this.clearPartGeometry();
    if (this._ready) {
      this.wasm.clearScene();
    }
  }

  fitToView() {
    // A simple default: position camera back to see the part
    if (!this._ready) return;
    if (this.mode === '3d') {
      this.wasm.setCameraPosition(300, 300, 300);
      this.wasm.setCameraTarget(0, 0, 0);
    }
  }

  /**
   * Convert screen coordinates to world coordinates on the XY plane.
   */
  screenToWorld(screenX, screenY) {
    const rect = this.canvas.getBoundingClientRect();
    const ndcX = ((screenX - rect.left) / rect.width) * 2 - 1;
    const ndcY = -((screenY - rect.top) / rect.height) * 2 + 1;

    const bounds = this._orthoBounds;
    const wx = bounds.left + (ndcX + 1) * 0.5 * (bounds.right - bounds.left);
    const wy = bounds.bottom + (ndcY + 1) * 0.5 * (bounds.top - bounds.bottom);
    return { x: wx, y: wy };
  }

  dispose() {
    if (this._animationId) {
      cancelAnimationFrame(this._animationId);
    }
    this.clearGeometry();
    this.executor.dispose();
    if (this._resizeHandler) {
      window.removeEventListener('resize', this._resizeHandler);
    }
    if (this.canvas.parentNode) {
      this.canvas.parentNode.removeChild(this.canvas);
    }
    if (this.overlayCanvas.parentNode) {
      this.overlayCanvas.parentNode.removeChild(this.overlayCanvas);
    }
  }
}
